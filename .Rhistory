}
# ---- 3. Compute all paths in parallel ----
message("Computing paths for all trees in parallel...")
all_paths <- future_lapply(1:n_tree, get_paths, future.packages = "randomForest")
# ---- 4. Compute proximity matrix in parallel ----
message("Calculating path proximity matrix in parallel...")
proximity <- matrix(0, nrow = n, ncol = n)
p <- progressor(steps = n_tree)
tree_jaccard <- function(b) {
paths <- all_paths[[b]]
mtx <- matrix(0, nrow = n, ncol = n)
for (i in 1:n) {
Ti <- paths[[i]]
for (j in i:n) {
Tj <- paths[[j]]
intersect_len <- length(intersect(Ti, Tj))
union_len <- length(union(Ti, Tj))
jaccard <- intersect_len / union_len
mtx[i, j] <- jaccard
if (i != j) mtx[j, i] <- jaccard
}
}
p()
return(mtx)
}
with_progress({
mtx_list <- future_lapply(1:n_tree, tree_jaccard)
})
# ---- 5. Aggregate and normalize the results ----
for (m in mtx_list) {
proximity <- proximity + m
}
proximity <- proximity / n_tree
rownames(proximity) <- rownames(data)
colnames(proximity) <- rownames(data)
return(proximity)
}
P <- compute_path_proximity(data)
off_diag_values <- P[lower.tri(P)]
summary(off_diag_values)
hist(off_diag_values)
zero_ratio <- mean(off_diag_values == 0)
cat("Proportion of exact zeros in off-diagonal:", round(zero_ratio * 100, 2), "%\n")
diag_values <- diag(P)
summary(diag_values)
library(tidyverse)
library(tidyverse)
library(randomForest)
library(sf)
library(pbapply)
library(future)
install.packages("future")
library(future)
library(tidyverse)
library(randomForest)
library(sf)
library(pbapply)
library(future)
library(future.apply)
library(progressr)
library(Guerry)
library(sp)
library(tmap)
gfrance85 <- st_as_sf(gfrance85)
qtm(gfrance85)
names(gfrance85)
data <- gfrance85 |>
st_drop_geometry() |>
dplyr::select(Region, Crime_pers, Crime_prop, Literacy, Donations, Infants)
compute_path_proximity <- function(data, n_tree = 500, workers = 2) {
set.seed(42)
# ---- 0. Set parallel computing environment ----
plan(multisession, workers = workers)
handlers(global = TRUE)
n <- nrow(data)
# ---- 1. Random Forest modeling (Addcl1 method) ----
synthetic <- as.data.frame(lapply(data, function(col) sample(col, replace = TRUE)))
data_all <- rbind(data, synthetic)
y_all <- factor(c(rep("real", nrow(data)), rep("synthetic", nrow(synthetic))))
rf <- randomForest(x = data_all,
y = y_all,
ntree = n_tree)
# --- [ê²€ì¦ ì½”ë“œ ì‹œìž‘] ---
# ê°€ì •: rf, data_all, n_tree, get_paths í•¨ìˆ˜ê°€ ë©”ëª¨ë¦¬ì— ë¡œë“œë˜ì–´ ìžˆëŠ” ìƒíƒœ
message("--- Starting Validation Process ---")
# --- 1. 'ì •ë‹µ' ê°€ì ¸ì˜¤ê¸°: predict() í•¨ìˆ˜ë¡œ ì‹¤ì œ ë§ë‹¨ ë…¸ë“œ ID í™•ë³´ ---
# randomForest íŒ¨í‚¤ì§€ì˜ predict í•¨ìˆ˜ëŠ” ê° ê´€ì¸¡ì¹˜ê°€ ê° íŠ¸ë¦¬ì—ì„œ
# ìµœì¢…ì ìœ¼ë¡œ ì–´ë–¤ ë§ë‹¨ ë…¸ë“œì— ë„ë‹¬í–ˆëŠ”ì§€ ì •í™•í•œ ì •ë³´ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
message("Step 1: Getting ground truth terminal nodes from predict()...")
predicted_nodes <- attr(predict(rf, data_all, nodes = TRUE), "nodes")
# ê²°ê³¼: (2n x n_tree) í¬ê¸°ì˜ í–‰ë ¬. [i, t] ì›ì†ŒëŠ” iê´€ì¸¡ì¹˜ì˜ të²ˆì§¸ íŠ¸ë¦¬ ë§ë‹¨ ë…¸ë“œ ID.
# --- 2. 'ë‚´ ì½”ë“œì˜ ë‹µ' ê°€ì ¸ì˜¤ê¸°: get_paths() í•¨ìˆ˜ë¡œ ê²½ë¡œ ê³„ì‚° ---
# ìž‘ì„±í•˜ì‹  ì½”ë“œë¥¼ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•˜ì—¬ ëª¨ë“  íŠ¸ë¦¬ì˜ ê²½ë¡œë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
message("Step 2: Computing user-generated paths for all trees...")
all_user_paths <- future_lapply(1:n_tree, get_paths, future.packages = "randomForest")
# --- 3. ì •ë‹µê³¼ ë‚´ ì½”ë“œì˜ ë‹µ ë¹„êµ ---
message("Step 3: Comparing user-generated paths with ground truth...")
mismatch_found <- FALSE
mismatch_details <- list()
for (t in 1:n_tree) {
# të²ˆì§¸ íŠ¸ë¦¬ì˜ 'ì •ë‹µ' ë§ë‹¨ ë…¸ë“œ ë²¡í„°
truth_nodes_for_tree_t <- predicted_nodes[, t]
# të²ˆì§¸ íŠ¸ë¦¬ì˜ 'ë‚´ ì½”ë“œ'ê°€ ê³„ì‚°í•œ ê²½ë¡œ ë¦¬ìŠ¤íŠ¸
user_paths_for_tree_t <- all_user_paths[[t]]
# 'ë‚´ ì½”ë“œ' ê²½ë¡œì—ì„œ ë§ˆì§€ë§‰ ë…¸ë“œ(ë§ë‹¨ ë…¸ë“œ)ë§Œ ì¶”ì¶œ
user_final_nodes_for_tree_t <- sapply(user_paths_for_tree_t, function(p) p[length(p)])
# ë‘ ë²¡í„°ê°€ ì™„ì „ížˆ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸
if (!all(truth_nodes_for_tree_t == user_final_nodes_for_tree_t)) {
mismatch_found <- TRUE
# ë¶ˆì¼ì¹˜ê°€ ë°œìƒí•œ ì²« ë²ˆì§¸ ê´€ì¸¡ì¹˜ ì¸ë±ìŠ¤ ì°¾ê¸° (ë¦¬í¬íŒ…ìš©)
first_mismatch_idx <- which(truth_nodes_for_tree_t != user_final_nodes_for_tree_t)[1]
# ë¶ˆì¼ì¹˜ ì •ë³´ ì €ìž¥
mismatch_info <- list(
tree_number = t,
first_mismatch_at_observation_index = first_mismatch_idx,
ground_truth_node = truth_nodes_for_tree_t[first_mismatch_idx],
user_generated_final_node = user_final_nodes_for_tree_t[first_mismatch_idx]
)
mismatch_details[[length(mismatch_details) + 1]] <- mismatch_info
}
}
# --- 4. ìµœì¢… ê²°ê³¼ ë¦¬í¬íŠ¸ ---
message("\n--- Validation Report ---")
if (mismatch_found) {
cat("ðŸ”´ Mismatch Found! 'get_paths' í•¨ìˆ˜ê°€ randomForestì˜ ì‹¤ì œ ê²½ë¡œì™€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\n\n")
cat("ë¶ˆì¼ì¹˜ê°€ ë°œê²¬ëœ íŠ¸ë¦¬ì˜ ìƒì„¸ ì •ë³´:\n")
for(info in mismatch_details) {
cat(sprintf("  - Tree #%d: Observation #%dì—ì„œ ë¶ˆì¼ì¹˜ (ì •ë‹µ ë…¸ë“œ: %d, ë‚´ ì½”ë“œ ê²°ê³¼: %d)\n",
info$tree_number,
info$first_mismatch_at_observation_index,
info$ground_truth_node,
info$user_generated_final_node))
}
cat("\nâž¡ï¸ ì¶”ì²œ: ë²”ì£¼í˜• ë³€ìˆ˜(factor) ì²˜ë¦¬ ë¡œì§ì„ ê²€í† í•´ì•¼ í•©ë‹ˆë‹¤.\n")
} else {
cat("âœ… Success! ëª¨ë“  ìƒì„± ê²½ë¡œê°€ predict() í•¨ìˆ˜ì˜ ê²°ê³¼ì™€ ì™„ë²½í•˜ê²Œ ì¼ì¹˜í•©ë‹ˆë‹¤.\n")
cat("âž¡ï¸ 'get_paths' í•¨ìˆ˜ì˜ ì •í™•ì„±ì´ ê²€ì¦ë˜ì—ˆìŠµë‹ˆë‹¤.\n")
}
# --- [ê²€ì¦ ì½”ë“œ ì¢…ë£Œ] ---
# ---- 2. Function to compute paths for each tree ----
get_paths <- function(tree_num) {
tree <- getTree(rf, k = tree_num, labelVar = FALSE)
paths <- vector("list", 2 * n)
for (i in 1:(2 * n)) {
path <- c()
node <- 1
repeat {
path <- c(path, node)
split_var <- tree[node, "split var"]
if (split_var == 0) break
split_val <- tree[node, "split point"]
split_var_name <- colnames(data_all)[split_var]
value <- data_all[i, split_var_name]
if (is.factor(data_all[[split_var_name]])) {
# ë²”ì£¼í˜• ë³€ìˆ˜ ì²˜ë¦¬: split_valì€ ë ˆë²¨ ì¸ë±ìŠ¤
levels_list <- levels(data_all[[split_var_name]])
left_levels <- levels_list[1:split_val]
if (as.character(value) %in% left_levels) {
node <- tree[node, "left daughter"]
} else {
node <- tree[node, "right daughter"]
}
} else {
# ìˆ˜ì¹˜í˜• ë³€ìˆ˜ ì²˜ë¦¬
if (value <= split_val) {
node <- tree[node, "left daughter"]
} else {
node <- tree[node, "right daughter"]
}
}
}
paths[[i]] <- path
}
return(paths)
}
# ---- 3. Compute all paths in parallel ----
message("Computing paths for all trees in parallel...")
all_paths <- future_lapply(1:n_tree, get_paths, future.packages = "randomForest")
# ---- 4. Compute proximity matrix in parallel ----
message("Calculating path proximity matrix in parallel...")
proximity <- matrix(0, nrow = n, ncol = n)
p <- progressor(steps = n_tree)
tree_jaccard <- function(b) {
paths <- all_paths[[b]]
mtx <- matrix(0, nrow = n, ncol = n)
for (i in 1:n) {
Ti <- paths[[i]]
for (j in i:n) {
Tj <- paths[[j]]
intersect_len <- length(intersect(Ti, Tj))
union_len <- length(union(Ti, Tj))
jaccard <- intersect_len / union_len
mtx[i, j] <- jaccard
if (i != j) mtx[j, i] <- jaccard
}
}
p()
return(mtx)
}
with_progress({
mtx_list <- future_lapply(1:n_tree, tree_jaccard)
})
# ---- 5. Aggregate and normalize the results ----
for (m in mtx_list) {
proximity <- proximity + m
}
proximity <- proximity / n_tree
rownames(proximity) <- rownames(data)
colnames(proximity) <- rownames(data)
return(proximity)
}
P <- compute_path_proximity(data)
compute_path_proximity <- function(data, n_tree = 500, workers = 2) {
set.seed(42)
# ---- 0. Set parallel computing environment ----
plan(multisession, workers = workers)
handlers(global = TRUE)
n <- nrow(data)
# ---- 1. Random Forest modeling (Addcl1 method) ----
synthetic <- as.data.frame(lapply(data, function(col) sample(col, replace = TRUE)))
data_all <- rbind(data, synthetic)
y_all <- factor(c(rep("real", nrow(data)), rep("synthetic", nrow(synthetic))))
rf <- randomForest(x = data_all,
y = y_all,
ntree = n_tree)
# ---- 2. Function to compute paths for each tree ----
get_paths <- function(tree_num) {
tree <- getTree(rf, k = tree_num, labelVar = FALSE)
paths <- vector("list", 2 * n)
for (i in 1:(2 * n)) {
path <- c()
node <- 1
repeat {
path <- c(path, node)
split_var <- tree[node, "split var"]
if (split_var == 0) break
split_val <- tree[node, "split point"]
split_var_name <- colnames(data_all)[split_var]
value <- data_all[i, split_var_name]
if (is.factor(data_all[[split_var_name]])) {
# ë²”ì£¼í˜• ë³€ìˆ˜ ì²˜ë¦¬: split_valì€ ë ˆë²¨ ì¸ë±ìŠ¤
levels_list <- levels(data_all[[split_var_name]])
left_levels <- levels_list[1:split_val]
if (as.character(value) %in% left_levels) {
node <- tree[node, "left daughter"]
} else {
node <- tree[node, "right daughter"]
}
} else {
# ìˆ˜ì¹˜í˜• ë³€ìˆ˜ ì²˜ë¦¬
if (value <= split_val) {
node <- tree[node, "left daughter"]
} else {
node <- tree[node, "right daughter"]
}
}
}
paths[[i]] <- path
}
return(paths)
}
# --- [ê²€ì¦ ì½”ë“œ ì‹œìž‘] ---
# ê°€ì •: rf, data_all, n_tree, get_paths í•¨ìˆ˜ê°€ ë©”ëª¨ë¦¬ì— ë¡œë“œë˜ì–´ ìžˆëŠ” ìƒíƒœ
message("--- Starting Validation Process ---")
# --- 1. 'ì •ë‹µ' ê°€ì ¸ì˜¤ê¸°: predict() í•¨ìˆ˜ë¡œ ì‹¤ì œ ë§ë‹¨ ë…¸ë“œ ID í™•ë³´ ---
# randomForest íŒ¨í‚¤ì§€ì˜ predict í•¨ìˆ˜ëŠ” ê° ê´€ì¸¡ì¹˜ê°€ ê° íŠ¸ë¦¬ì—ì„œ
# ìµœì¢…ì ìœ¼ë¡œ ì–´ë–¤ ë§ë‹¨ ë…¸ë“œì— ë„ë‹¬í–ˆëŠ”ì§€ ì •í™•í•œ ì •ë³´ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
message("Step 1: Getting ground truth terminal nodes from predict()...")
predicted_nodes <- attr(predict(rf, data_all, nodes = TRUE), "nodes")
# ê²°ê³¼: (2n x n_tree) í¬ê¸°ì˜ í–‰ë ¬. [i, t] ì›ì†ŒëŠ” iê´€ì¸¡ì¹˜ì˜ të²ˆì§¸ íŠ¸ë¦¬ ë§ë‹¨ ë…¸ë“œ ID.
# --- 2. 'ë‚´ ì½”ë“œì˜ ë‹µ' ê°€ì ¸ì˜¤ê¸°: get_paths() í•¨ìˆ˜ë¡œ ê²½ë¡œ ê³„ì‚° ---
# ìž‘ì„±í•˜ì‹  ì½”ë“œë¥¼ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•˜ì—¬ ëª¨ë“  íŠ¸ë¦¬ì˜ ê²½ë¡œë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
message("Step 2: Computing user-generated paths for all trees...")
all_user_paths <- future_lapply(1:n_tree, get_paths, future.packages = "randomForest")
# --- 3. ì •ë‹µê³¼ ë‚´ ì½”ë“œì˜ ë‹µ ë¹„êµ ---
message("Step 3: Comparing user-generated paths with ground truth...")
mismatch_found <- FALSE
mismatch_details <- list()
for (t in 1:n_tree) {
# të²ˆì§¸ íŠ¸ë¦¬ì˜ 'ì •ë‹µ' ë§ë‹¨ ë…¸ë“œ ë²¡í„°
truth_nodes_for_tree_t <- predicted_nodes[, t]
# të²ˆì§¸ íŠ¸ë¦¬ì˜ 'ë‚´ ì½”ë“œ'ê°€ ê³„ì‚°í•œ ê²½ë¡œ ë¦¬ìŠ¤íŠ¸
user_paths_for_tree_t <- all_user_paths[[t]]
# 'ë‚´ ì½”ë“œ' ê²½ë¡œì—ì„œ ë§ˆì§€ë§‰ ë…¸ë“œ(ë§ë‹¨ ë…¸ë“œ)ë§Œ ì¶”ì¶œ
user_final_nodes_for_tree_t <- sapply(user_paths_for_tree_t, function(p) p[length(p)])
# ë‘ ë²¡í„°ê°€ ì™„ì „ížˆ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸
if (!all(truth_nodes_for_tree_t == user_final_nodes_for_tree_t)) {
mismatch_found <- TRUE
# ë¶ˆì¼ì¹˜ê°€ ë°œìƒí•œ ì²« ë²ˆì§¸ ê´€ì¸¡ì¹˜ ì¸ë±ìŠ¤ ì°¾ê¸° (ë¦¬í¬íŒ…ìš©)
first_mismatch_idx <- which(truth_nodes_for_tree_t != user_final_nodes_for_tree_t)[1]
# ë¶ˆì¼ì¹˜ ì •ë³´ ì €ìž¥
mismatch_info <- list(
tree_number = t,
first_mismatch_at_observation_index = first_mismatch_idx,
ground_truth_node = truth_nodes_for_tree_t[first_mismatch_idx],
user_generated_final_node = user_final_nodes_for_tree_t[first_mismatch_idx]
)
mismatch_details[[length(mismatch_details) + 1]] <- mismatch_info
}
}
# --- 4. ìµœì¢… ê²°ê³¼ ë¦¬í¬íŠ¸ ---
message("\n--- Validation Report ---")
if (mismatch_found) {
cat("ðŸ”´ Mismatch Found! 'get_paths' í•¨ìˆ˜ê°€ randomForestì˜ ì‹¤ì œ ê²½ë¡œì™€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\n\n")
cat("ë¶ˆì¼ì¹˜ê°€ ë°œê²¬ëœ íŠ¸ë¦¬ì˜ ìƒì„¸ ì •ë³´:\n")
for(info in mismatch_details) {
cat(sprintf("  - Tree #%d: Observation #%dì—ì„œ ë¶ˆì¼ì¹˜ (ì •ë‹µ ë…¸ë“œ: %d, ë‚´ ì½”ë“œ ê²°ê³¼: %d)\n",
info$tree_number,
info$first_mismatch_at_observation_index,
info$ground_truth_node,
info$user_generated_final_node))
}
cat("\nâž¡ï¸ ì¶”ì²œ: ë²”ì£¼í˜• ë³€ìˆ˜(factor) ì²˜ë¦¬ ë¡œì§ì„ ê²€í† í•´ì•¼ í•©ë‹ˆë‹¤.\n")
} else {
cat("âœ… Success! ëª¨ë“  ìƒì„± ê²½ë¡œê°€ predict() í•¨ìˆ˜ì˜ ê²°ê³¼ì™€ ì™„ë²½í•˜ê²Œ ì¼ì¹˜í•©ë‹ˆë‹¤.\n")
cat("âž¡ï¸ 'get_paths' í•¨ìˆ˜ì˜ ì •í™•ì„±ì´ ê²€ì¦ë˜ì—ˆìŠµë‹ˆë‹¤.\n")
}
# --- [ê²€ì¦ ì½”ë“œ ì¢…ë£Œ] ---
# ---- 3. Compute all paths in parallel ----
message("Computing paths for all trees in parallel...")
all_paths <- future_lapply(1:n_tree, get_paths, future.packages = "randomForest")
# ---- 4. Compute proximity matrix in parallel ----
message("Calculating path proximity matrix in parallel...")
proximity <- matrix(0, nrow = n, ncol = n)
p <- progressor(steps = n_tree)
tree_jaccard <- function(b) {
paths <- all_paths[[b]]
mtx <- matrix(0, nrow = n, ncol = n)
for (i in 1:n) {
Ti <- paths[[i]]
for (j in i:n) {
Tj <- paths[[j]]
intersect_len <- length(intersect(Ti, Tj))
union_len <- length(union(Ti, Tj))
jaccard <- intersect_len / union_len
mtx[i, j] <- jaccard
if (i != j) mtx[j, i] <- jaccard
}
}
p()
return(mtx)
}
with_progress({
mtx_list <- future_lapply(1:n_tree, tree_jaccard)
})
# ---- 5. Aggregate and normalize the results ----
for (m in mtx_list) {
proximity <- proximity + m
}
proximity <- proximity / n_tree
rownames(proximity) <- rownames(data)
colnames(proximity) <- rownames(data)
return(proximity)
}
P <- compute_path_proximity(data)
compute_path_proximity <- function(data, n_tree = 500, workers = 2) {
set.seed(42)
# ---- 0. Set parallel computing environment ----
plan(multisession, workers = workers)
handlers(global = TRUE)
n <- nrow(data)
# ---- 1. Random Forest modeling (Addcl1 method) ----
synthetic <- as.data.frame(lapply(data, function(col) sample(col, replace = TRUE)))
data_all <- rbind(data, synthetic)
y_all <- factor(c(rep("real", nrow(data)), rep("synthetic", nrow(synthetic))))
rf <- randomForest(x = data_all,
y = y_all,
ntree = n_tree)
# ---- 2. Function to compute paths for each tree ----
get_paths <- function(tree_num) {
tree <- getTree(rf, k = tree_num, labelVar = FALSE)
paths <- vector("list", 2 * n)
for (i in 1:(2 * n)) {
path <- c()
node <- 1
repeat {
path <- c(path, node)
split_var <- tree[node, "split var"]
if (split_var == 0) break
split_val <- tree[node, "split point"]
split_var_name <- colnames(data_all)[split_var]
value <- data_all[i, split_var_name]
if (is.factor(data_all[[split_var_name]])) {
# 'split point'ëŠ” ì–´ë–¤ ë ˆë²¨ì´ ì™¼ìª½ìœ¼ë¡œ ê°ˆì§€ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ë¹„íŠ¸ë§ˆìŠ¤í¬ ì •ìˆ˜ìž…ë‹ˆë‹¤.
# 1. split_val ì •ìˆ˜ë¥¼ ë¹„íŠ¸ ë²¡í„°ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
#    (randomForestëŠ” ìµœëŒ€ 32ê°œ ë ˆë²¨ê¹Œì§€ ì´ëŸ° ë°©ì‹ìœ¼ë¡œ ì¸ì½”ë”©í•©ë‹ˆë‹¤)
split_bits <- intToBits(split_val)
# 2. í˜„ìž¬ ê´€ì¸¡ì¹˜ ê°’ì˜ ë ˆë²¨ì´ ëª‡ ë²ˆì§¸ ì¸ë±ìŠ¤ì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤.
#    (ì˜ˆ: 'B' ë ˆë²¨ì´ íŒ©í„°ì˜ ë‘ ë²ˆì§¸ ë ˆë²¨ì´ë¼ë©´ value_level_indexëŠ” 2)
value_level_index <- as.integer(value)
# 3. í•´ë‹¹ ì¸ë±ìŠ¤ì˜ ë¹„íŠ¸ê°€ 1ì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤.
#    ë¹„íŠ¸ê°€ 1ì´ë©´(as.raw(1)) í•´ë‹¹ ë ˆë²¨ì€ ì™¼ìª½ ìžì‹ ë…¸ë“œë¡œ ê°‘ë‹ˆë‹¤.
if (split_bits[value_level_index] == as.raw(1)) {
node <- tree[node, "left daughter"]
} else {
node <- tree[node, "right daughter"]
}
} else {
# ìˆ˜ì¹˜í˜• ë³€ìˆ˜ ì²˜ë¦¬ ë¡œì§ì€ ê¸°ì¡´ê³¼ ë™ì¼í•˜ê²Œ ìœ ì§€í•©ë‹ˆë‹¤.
if (value <= split_val) {
node <- tree[node, "left daughter"]
} else {
node <- tree[node, "right daughter"]
}
}
}
paths[[i]] <- path
}
return(paths)
}
# --- [ê²€ì¦ ì½”ë“œ ì‹œìž‘] ---
# ê°€ì •: rf, data_all, n_tree, get_paths í•¨ìˆ˜ê°€ ë©”ëª¨ë¦¬ì— ë¡œë“œë˜ì–´ ìžˆëŠ” ìƒíƒœ
message("--- Starting Validation Process ---")
# --- 1. 'ì •ë‹µ' ê°€ì ¸ì˜¤ê¸°: predict() í•¨ìˆ˜ë¡œ ì‹¤ì œ ë§ë‹¨ ë…¸ë“œ ID í™•ë³´ ---
# randomForest íŒ¨í‚¤ì§€ì˜ predict í•¨ìˆ˜ëŠ” ê° ê´€ì¸¡ì¹˜ê°€ ê° íŠ¸ë¦¬ì—ì„œ
# ìµœì¢…ì ìœ¼ë¡œ ì–´ë–¤ ë§ë‹¨ ë…¸ë“œì— ë„ë‹¬í–ˆëŠ”ì§€ ì •í™•í•œ ì •ë³´ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
message("Step 1: Getting ground truth terminal nodes from predict()...")
predicted_nodes <- attr(predict(rf, data_all, nodes = TRUE), "nodes")
# ê²°ê³¼: (2n x n_tree) í¬ê¸°ì˜ í–‰ë ¬. [i, t] ì›ì†ŒëŠ” iê´€ì¸¡ì¹˜ì˜ të²ˆì§¸ íŠ¸ë¦¬ ë§ë‹¨ ë…¸ë“œ ID.
# --- 2. 'ë‚´ ì½”ë“œì˜ ë‹µ' ê°€ì ¸ì˜¤ê¸°: get_paths() í•¨ìˆ˜ë¡œ ê²½ë¡œ ê³„ì‚° ---
# ìž‘ì„±í•˜ì‹  ì½”ë“œë¥¼ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•˜ì—¬ ëª¨ë“  íŠ¸ë¦¬ì˜ ê²½ë¡œë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
message("Step 2: Computing user-generated paths for all trees...")
all_user_paths <- future_lapply(1:n_tree, get_paths, future.packages = "randomForest")
# --- 3. ì •ë‹µê³¼ ë‚´ ì½”ë“œì˜ ë‹µ ë¹„êµ ---
message("Step 3: Comparing user-generated paths with ground truth...")
mismatch_found <- FALSE
mismatch_details <- list()
for (t in 1:n_tree) {
# të²ˆì§¸ íŠ¸ë¦¬ì˜ 'ì •ë‹µ' ë§ë‹¨ ë…¸ë“œ ë²¡í„°
truth_nodes_for_tree_t <- predicted_nodes[, t]
# të²ˆì§¸ íŠ¸ë¦¬ì˜ 'ë‚´ ì½”ë“œ'ê°€ ê³„ì‚°í•œ ê²½ë¡œ ë¦¬ìŠ¤íŠ¸
user_paths_for_tree_t <- all_user_paths[[t]]
# 'ë‚´ ì½”ë“œ' ê²½ë¡œì—ì„œ ë§ˆì§€ë§‰ ë…¸ë“œ(ë§ë‹¨ ë…¸ë“œ)ë§Œ ì¶”ì¶œ
user_final_nodes_for_tree_t <- sapply(user_paths_for_tree_t, function(p) p[length(p)])
# ë‘ ë²¡í„°ê°€ ì™„ì „ížˆ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸
if (!all(truth_nodes_for_tree_t == user_final_nodes_for_tree_t)) {
mismatch_found <- TRUE
# ë¶ˆì¼ì¹˜ê°€ ë°œìƒí•œ ì²« ë²ˆì§¸ ê´€ì¸¡ì¹˜ ì¸ë±ìŠ¤ ì°¾ê¸° (ë¦¬í¬íŒ…ìš©)
first_mismatch_idx <- which(truth_nodes_for_tree_t != user_final_nodes_for_tree_t)[1]
# ë¶ˆì¼ì¹˜ ì •ë³´ ì €ìž¥
mismatch_info <- list(
tree_number = t,
first_mismatch_at_observation_index = first_mismatch_idx,
ground_truth_node = truth_nodes_for_tree_t[first_mismatch_idx],
user_generated_final_node = user_final_nodes_for_tree_t[first_mismatch_idx]
)
mismatch_details[[length(mismatch_details) + 1]] <- mismatch_info
}
}
# --- 4. ìµœì¢… ê²°ê³¼ ë¦¬í¬íŠ¸ ---
message("\n--- Validation Report ---")
if (mismatch_found) {
cat("ðŸ”´ Mismatch Found! 'get_paths' í•¨ìˆ˜ê°€ randomForestì˜ ì‹¤ì œ ê²½ë¡œì™€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\n\n")
cat("ë¶ˆì¼ì¹˜ê°€ ë°œê²¬ëœ íŠ¸ë¦¬ì˜ ìƒì„¸ ì •ë³´:\n")
for(info in mismatch_details) {
cat(sprintf("  - Tree #%d: Observation #%dì—ì„œ ë¶ˆì¼ì¹˜ (ì •ë‹µ ë…¸ë“œ: %d, ë‚´ ì½”ë“œ ê²°ê³¼: %d)\n",
info$tree_number,
info$first_mismatch_at_observation_index,
info$ground_truth_node,
info$user_generated_final_node))
}
cat("\nâž¡ï¸ ì¶”ì²œ: ë²”ì£¼í˜• ë³€ìˆ˜(factor) ì²˜ë¦¬ ë¡œì§ì„ ê²€í† í•´ì•¼ í•©ë‹ˆë‹¤.\n")
} else {
cat("âœ… Success! ëª¨ë“  ìƒì„± ê²½ë¡œê°€ predict() í•¨ìˆ˜ì˜ ê²°ê³¼ì™€ ì™„ë²½í•˜ê²Œ ì¼ì¹˜í•©ë‹ˆë‹¤.\n")
cat("âž¡ï¸ 'get_paths' í•¨ìˆ˜ì˜ ì •í™•ì„±ì´ ê²€ì¦ë˜ì—ˆìŠµë‹ˆë‹¤.\n")
}
# --- [ê²€ì¦ ì½”ë“œ ì¢…ë£Œ] ---
# ---- 3. Compute all paths in parallel ----
message("Computing paths for all trees in parallel...")
all_paths <- future_lapply(1:n_tree, get_paths, future.packages = "randomForest")
# ---- 4. Compute proximity matrix in parallel ----
message("Calculating path proximity matrix in parallel...")
proximity <- matrix(0, nrow = n, ncol = n)
p <- progressor(steps = n_tree)
tree_jaccard <- function(b) {
paths <- all_paths[[b]]
mtx <- matrix(0, nrow = n, ncol = n)
for (i in 1:n) {
Ti <- paths[[i]]
for (j in i:n) {
Tj <- paths[[j]]
intersect_len <- length(intersect(Ti, Tj))
union_len <- length(union(Ti, Tj))
jaccard <- intersect_len / union_len
mtx[i, j] <- jaccard
if (i != j) mtx[j, i] <- jaccard
}
}
p()
return(mtx)
}
with_progress({
mtx_list <- future_lapply(1:n_tree, tree_jaccard)
})
# ---- 5. Aggregate and normalize the results ----
for (m in mtx_list) {
proximity <- proximity + m
}
proximity <- proximity / n_tree
rownames(proximity) <- rownames(data)
colnames(proximity) <- rownames(data)
return(proximity)
}
P <- compute_path_proximity(data)
write_rds(P, "PathProximity.rds")
off_diag_values <- P[lower.tri(P)]
summary(off_diag_values)
hist(off_diag_values)
zero_ratio <- mean(off_diag_values == 0)
cat("Proportion of exact zeros in off-diagonal:", round(zero_ratio * 100, 2), "%\n")
diag_values <- diag(P)
summary(diag_values)
