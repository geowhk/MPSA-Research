}
# ---- 3. Compute all paths in parallel ----
message("Computing paths for all trees in parallel...")
all_paths <- future_lapply(1:n_tree, get_paths, future.packages = "randomForest")
# ---- 4. Compute proximity matrix in parallel ----
message("Calculating path proximity matrix in parallel...")
proximity <- matrix(0, nrow = n, ncol = n)
p <- progressor(steps = n_tree)
tree_jaccard <- function(b) {
paths <- all_paths[[b]]
mtx <- matrix(0, nrow = n, ncol = n)
for (i in 1:n) {
Ti <- paths[[i]]
for (j in i:n) {
Tj <- paths[[j]]
intersect_len <- length(intersect(Ti, Tj))
union_len <- length(union(Ti, Tj))
jaccard <- intersect_len / union_len
mtx[i, j] <- jaccard
if (i != j) mtx[j, i] <- jaccard
}
}
p()
return(mtx)
}
with_progress({
mtx_list <- future_lapply(1:n_tree, tree_jaccard)
})
# ---- 5. Aggregate and normalize the results ----
for (m in mtx_list) {
proximity <- proximity + m
}
proximity <- proximity / n_tree
rownames(proximity) <- rownames(data)
colnames(proximity) <- rownames(data)
return(proximity)
}
P <- compute_path_proximity(data)
off_diag_values <- P[lower.tri(P)]
summary(off_diag_values)
hist(off_diag_values)
zero_ratio <- mean(off_diag_values == 0)
cat("Proportion of exact zeros in off-diagonal:", round(zero_ratio * 100, 2), "%\n")
diag_values <- diag(P)
summary(diag_values)
library(tidyverse)
library(tidyverse)
library(randomForest)
library(sf)
library(pbapply)
library(future)
install.packages("future")
library(future)
library(tidyverse)
library(randomForest)
library(sf)
library(pbapply)
library(future)
library(future.apply)
library(progressr)
library(Guerry)
library(sp)
library(tmap)
gfrance85 <- st_as_sf(gfrance85)
qtm(gfrance85)
names(gfrance85)
data <- gfrance85 |>
st_drop_geometry() |>
dplyr::select(Region, Crime_pers, Crime_prop, Literacy, Donations, Infants)
compute_path_proximity <- function(data, n_tree = 500, workers = 2) {
set.seed(42)
# ---- 0. Set parallel computing environment ----
plan(multisession, workers = workers)
handlers(global = TRUE)
n <- nrow(data)
# ---- 1. Random Forest modeling (Addcl1 method) ----
synthetic <- as.data.frame(lapply(data, function(col) sample(col, replace = TRUE)))
data_all <- rbind(data, synthetic)
y_all <- factor(c(rep("real", nrow(data)), rep("synthetic", nrow(synthetic))))
rf <- randomForest(x = data_all,
y = y_all,
ntree = n_tree)
# --- [검증 코드 시작] ---
# 가정: rf, data_all, n_tree, get_paths 함수가 메모리에 로드되어 있는 상태
message("--- Starting Validation Process ---")
# --- 1. '정답' 가져오기: predict() 함수로 실제 말단 노드 ID 확보 ---
# randomForest 패키지의 predict 함수는 각 관측치가 각 트리에서
# 최종적으로 어떤 말단 노드에 도달했는지 정확한 정보를 제공합니다.
message("Step 1: Getting ground truth terminal nodes from predict()...")
predicted_nodes <- attr(predict(rf, data_all, nodes = TRUE), "nodes")
# 결과: (2n x n_tree) 크기의 행렬. [i, t] 원소는 i관측치의 t번째 트리 말단 노드 ID.
# --- 2. '내 코드의 답' 가져오기: get_paths() 함수로 경로 계산 ---
# 작성하신 코드를 그대로 사용하여 모든 트리의 경로를 계산합니다.
message("Step 2: Computing user-generated paths for all trees...")
all_user_paths <- future_lapply(1:n_tree, get_paths, future.packages = "randomForest")
# --- 3. 정답과 내 코드의 답 비교 ---
message("Step 3: Comparing user-generated paths with ground truth...")
mismatch_found <- FALSE
mismatch_details <- list()
for (t in 1:n_tree) {
# t번째 트리의 '정답' 말단 노드 벡터
truth_nodes_for_tree_t <- predicted_nodes[, t]
# t번째 트리의 '내 코드'가 계산한 경로 리스트
user_paths_for_tree_t <- all_user_paths[[t]]
# '내 코드' 경로에서 마지막 노드(말단 노드)만 추출
user_final_nodes_for_tree_t <- sapply(user_paths_for_tree_t, function(p) p[length(p)])
# 두 벡터가 완전히 일치하는지 확인
if (!all(truth_nodes_for_tree_t == user_final_nodes_for_tree_t)) {
mismatch_found <- TRUE
# 불일치가 발생한 첫 번째 관측치 인덱스 찾기 (리포팅용)
first_mismatch_idx <- which(truth_nodes_for_tree_t != user_final_nodes_for_tree_t)[1]
# 불일치 정보 저장
mismatch_info <- list(
tree_number = t,
first_mismatch_at_observation_index = first_mismatch_idx,
ground_truth_node = truth_nodes_for_tree_t[first_mismatch_idx],
user_generated_final_node = user_final_nodes_for_tree_t[first_mismatch_idx]
)
mismatch_details[[length(mismatch_details) + 1]] <- mismatch_info
}
}
# --- 4. 최종 결과 리포트 ---
message("\n--- Validation Report ---")
if (mismatch_found) {
cat("🔴 Mismatch Found! 'get_paths' 함수가 randomForest의 실제 경로와 일치하지 않습니다.\n\n")
cat("불일치가 발견된 트리의 상세 정보:\n")
for(info in mismatch_details) {
cat(sprintf("  - Tree #%d: Observation #%d에서 불일치 (정답 노드: %d, 내 코드 결과: %d)\n",
info$tree_number,
info$first_mismatch_at_observation_index,
info$ground_truth_node,
info$user_generated_final_node))
}
cat("\n➡️ 추천: 범주형 변수(factor) 처리 로직을 검토해야 합니다.\n")
} else {
cat("✅ Success! 모든 생성 경로가 predict() 함수의 결과와 완벽하게 일치합니다.\n")
cat("➡️ 'get_paths' 함수의 정확성이 검증되었습니다.\n")
}
# --- [검증 코드 종료] ---
# ---- 2. Function to compute paths for each tree ----
get_paths <- function(tree_num) {
tree <- getTree(rf, k = tree_num, labelVar = FALSE)
paths <- vector("list", 2 * n)
for (i in 1:(2 * n)) {
path <- c()
node <- 1
repeat {
path <- c(path, node)
split_var <- tree[node, "split var"]
if (split_var == 0) break
split_val <- tree[node, "split point"]
split_var_name <- colnames(data_all)[split_var]
value <- data_all[i, split_var_name]
if (is.factor(data_all[[split_var_name]])) {
# 범주형 변수 처리: split_val은 레벨 인덱스
levels_list <- levels(data_all[[split_var_name]])
left_levels <- levels_list[1:split_val]
if (as.character(value) %in% left_levels) {
node <- tree[node, "left daughter"]
} else {
node <- tree[node, "right daughter"]
}
} else {
# 수치형 변수 처리
if (value <= split_val) {
node <- tree[node, "left daughter"]
} else {
node <- tree[node, "right daughter"]
}
}
}
paths[[i]] <- path
}
return(paths)
}
# ---- 3. Compute all paths in parallel ----
message("Computing paths for all trees in parallel...")
all_paths <- future_lapply(1:n_tree, get_paths, future.packages = "randomForest")
# ---- 4. Compute proximity matrix in parallel ----
message("Calculating path proximity matrix in parallel...")
proximity <- matrix(0, nrow = n, ncol = n)
p <- progressor(steps = n_tree)
tree_jaccard <- function(b) {
paths <- all_paths[[b]]
mtx <- matrix(0, nrow = n, ncol = n)
for (i in 1:n) {
Ti <- paths[[i]]
for (j in i:n) {
Tj <- paths[[j]]
intersect_len <- length(intersect(Ti, Tj))
union_len <- length(union(Ti, Tj))
jaccard <- intersect_len / union_len
mtx[i, j] <- jaccard
if (i != j) mtx[j, i] <- jaccard
}
}
p()
return(mtx)
}
with_progress({
mtx_list <- future_lapply(1:n_tree, tree_jaccard)
})
# ---- 5. Aggregate and normalize the results ----
for (m in mtx_list) {
proximity <- proximity + m
}
proximity <- proximity / n_tree
rownames(proximity) <- rownames(data)
colnames(proximity) <- rownames(data)
return(proximity)
}
P <- compute_path_proximity(data)
compute_path_proximity <- function(data, n_tree = 500, workers = 2) {
set.seed(42)
# ---- 0. Set parallel computing environment ----
plan(multisession, workers = workers)
handlers(global = TRUE)
n <- nrow(data)
# ---- 1. Random Forest modeling (Addcl1 method) ----
synthetic <- as.data.frame(lapply(data, function(col) sample(col, replace = TRUE)))
data_all <- rbind(data, synthetic)
y_all <- factor(c(rep("real", nrow(data)), rep("synthetic", nrow(synthetic))))
rf <- randomForest(x = data_all,
y = y_all,
ntree = n_tree)
# ---- 2. Function to compute paths for each tree ----
get_paths <- function(tree_num) {
tree <- getTree(rf, k = tree_num, labelVar = FALSE)
paths <- vector("list", 2 * n)
for (i in 1:(2 * n)) {
path <- c()
node <- 1
repeat {
path <- c(path, node)
split_var <- tree[node, "split var"]
if (split_var == 0) break
split_val <- tree[node, "split point"]
split_var_name <- colnames(data_all)[split_var]
value <- data_all[i, split_var_name]
if (is.factor(data_all[[split_var_name]])) {
# 범주형 변수 처리: split_val은 레벨 인덱스
levels_list <- levels(data_all[[split_var_name]])
left_levels <- levels_list[1:split_val]
if (as.character(value) %in% left_levels) {
node <- tree[node, "left daughter"]
} else {
node <- tree[node, "right daughter"]
}
} else {
# 수치형 변수 처리
if (value <= split_val) {
node <- tree[node, "left daughter"]
} else {
node <- tree[node, "right daughter"]
}
}
}
paths[[i]] <- path
}
return(paths)
}
# --- [검증 코드 시작] ---
# 가정: rf, data_all, n_tree, get_paths 함수가 메모리에 로드되어 있는 상태
message("--- Starting Validation Process ---")
# --- 1. '정답' 가져오기: predict() 함수로 실제 말단 노드 ID 확보 ---
# randomForest 패키지의 predict 함수는 각 관측치가 각 트리에서
# 최종적으로 어떤 말단 노드에 도달했는지 정확한 정보를 제공합니다.
message("Step 1: Getting ground truth terminal nodes from predict()...")
predicted_nodes <- attr(predict(rf, data_all, nodes = TRUE), "nodes")
# 결과: (2n x n_tree) 크기의 행렬. [i, t] 원소는 i관측치의 t번째 트리 말단 노드 ID.
# --- 2. '내 코드의 답' 가져오기: get_paths() 함수로 경로 계산 ---
# 작성하신 코드를 그대로 사용하여 모든 트리의 경로를 계산합니다.
message("Step 2: Computing user-generated paths for all trees...")
all_user_paths <- future_lapply(1:n_tree, get_paths, future.packages = "randomForest")
# --- 3. 정답과 내 코드의 답 비교 ---
message("Step 3: Comparing user-generated paths with ground truth...")
mismatch_found <- FALSE
mismatch_details <- list()
for (t in 1:n_tree) {
# t번째 트리의 '정답' 말단 노드 벡터
truth_nodes_for_tree_t <- predicted_nodes[, t]
# t번째 트리의 '내 코드'가 계산한 경로 리스트
user_paths_for_tree_t <- all_user_paths[[t]]
# '내 코드' 경로에서 마지막 노드(말단 노드)만 추출
user_final_nodes_for_tree_t <- sapply(user_paths_for_tree_t, function(p) p[length(p)])
# 두 벡터가 완전히 일치하는지 확인
if (!all(truth_nodes_for_tree_t == user_final_nodes_for_tree_t)) {
mismatch_found <- TRUE
# 불일치가 발생한 첫 번째 관측치 인덱스 찾기 (리포팅용)
first_mismatch_idx <- which(truth_nodes_for_tree_t != user_final_nodes_for_tree_t)[1]
# 불일치 정보 저장
mismatch_info <- list(
tree_number = t,
first_mismatch_at_observation_index = first_mismatch_idx,
ground_truth_node = truth_nodes_for_tree_t[first_mismatch_idx],
user_generated_final_node = user_final_nodes_for_tree_t[first_mismatch_idx]
)
mismatch_details[[length(mismatch_details) + 1]] <- mismatch_info
}
}
# --- 4. 최종 결과 리포트 ---
message("\n--- Validation Report ---")
if (mismatch_found) {
cat("🔴 Mismatch Found! 'get_paths' 함수가 randomForest의 실제 경로와 일치하지 않습니다.\n\n")
cat("불일치가 발견된 트리의 상세 정보:\n")
for(info in mismatch_details) {
cat(sprintf("  - Tree #%d: Observation #%d에서 불일치 (정답 노드: %d, 내 코드 결과: %d)\n",
info$tree_number,
info$first_mismatch_at_observation_index,
info$ground_truth_node,
info$user_generated_final_node))
}
cat("\n➡️ 추천: 범주형 변수(factor) 처리 로직을 검토해야 합니다.\n")
} else {
cat("✅ Success! 모든 생성 경로가 predict() 함수의 결과와 완벽하게 일치합니다.\n")
cat("➡️ 'get_paths' 함수의 정확성이 검증되었습니다.\n")
}
# --- [검증 코드 종료] ---
# ---- 3. Compute all paths in parallel ----
message("Computing paths for all trees in parallel...")
all_paths <- future_lapply(1:n_tree, get_paths, future.packages = "randomForest")
# ---- 4. Compute proximity matrix in parallel ----
message("Calculating path proximity matrix in parallel...")
proximity <- matrix(0, nrow = n, ncol = n)
p <- progressor(steps = n_tree)
tree_jaccard <- function(b) {
paths <- all_paths[[b]]
mtx <- matrix(0, nrow = n, ncol = n)
for (i in 1:n) {
Ti <- paths[[i]]
for (j in i:n) {
Tj <- paths[[j]]
intersect_len <- length(intersect(Ti, Tj))
union_len <- length(union(Ti, Tj))
jaccard <- intersect_len / union_len
mtx[i, j] <- jaccard
if (i != j) mtx[j, i] <- jaccard
}
}
p()
return(mtx)
}
with_progress({
mtx_list <- future_lapply(1:n_tree, tree_jaccard)
})
# ---- 5. Aggregate and normalize the results ----
for (m in mtx_list) {
proximity <- proximity + m
}
proximity <- proximity / n_tree
rownames(proximity) <- rownames(data)
colnames(proximity) <- rownames(data)
return(proximity)
}
P <- compute_path_proximity(data)
compute_path_proximity <- function(data, n_tree = 500, workers = 2) {
set.seed(42)
# ---- 0. Set parallel computing environment ----
plan(multisession, workers = workers)
handlers(global = TRUE)
n <- nrow(data)
# ---- 1. Random Forest modeling (Addcl1 method) ----
synthetic <- as.data.frame(lapply(data, function(col) sample(col, replace = TRUE)))
data_all <- rbind(data, synthetic)
y_all <- factor(c(rep("real", nrow(data)), rep("synthetic", nrow(synthetic))))
rf <- randomForest(x = data_all,
y = y_all,
ntree = n_tree)
# ---- 2. Function to compute paths for each tree ----
get_paths <- function(tree_num) {
tree <- getTree(rf, k = tree_num, labelVar = FALSE)
paths <- vector("list", 2 * n)
for (i in 1:(2 * n)) {
path <- c()
node <- 1
repeat {
path <- c(path, node)
split_var <- tree[node, "split var"]
if (split_var == 0) break
split_val <- tree[node, "split point"]
split_var_name <- colnames(data_all)[split_var]
value <- data_all[i, split_var_name]
if (is.factor(data_all[[split_var_name]])) {
# 'split point'는 어떤 레벨이 왼쪽으로 갈지를 나타내는 비트마스크 정수입니다.
# 1. split_val 정수를 비트 벡터로 변환합니다.
#    (randomForest는 최대 32개 레벨까지 이런 방식으로 인코딩합니다)
split_bits <- intToBits(split_val)
# 2. 현재 관측치 값의 레벨이 몇 번째 인덱스인지 확인합니다.
#    (예: 'B' 레벨이 팩터의 두 번째 레벨이라면 value_level_index는 2)
value_level_index <- as.integer(value)
# 3. 해당 인덱스의 비트가 1인지 확인합니다.
#    비트가 1이면(as.raw(1)) 해당 레벨은 왼쪽 자식 노드로 갑니다.
if (split_bits[value_level_index] == as.raw(1)) {
node <- tree[node, "left daughter"]
} else {
node <- tree[node, "right daughter"]
}
} else {
# 수치형 변수 처리 로직은 기존과 동일하게 유지합니다.
if (value <= split_val) {
node <- tree[node, "left daughter"]
} else {
node <- tree[node, "right daughter"]
}
}
}
paths[[i]] <- path
}
return(paths)
}
# --- [검증 코드 시작] ---
# 가정: rf, data_all, n_tree, get_paths 함수가 메모리에 로드되어 있는 상태
message("--- Starting Validation Process ---")
# --- 1. '정답' 가져오기: predict() 함수로 실제 말단 노드 ID 확보 ---
# randomForest 패키지의 predict 함수는 각 관측치가 각 트리에서
# 최종적으로 어떤 말단 노드에 도달했는지 정확한 정보를 제공합니다.
message("Step 1: Getting ground truth terminal nodes from predict()...")
predicted_nodes <- attr(predict(rf, data_all, nodes = TRUE), "nodes")
# 결과: (2n x n_tree) 크기의 행렬. [i, t] 원소는 i관측치의 t번째 트리 말단 노드 ID.
# --- 2. '내 코드의 답' 가져오기: get_paths() 함수로 경로 계산 ---
# 작성하신 코드를 그대로 사용하여 모든 트리의 경로를 계산합니다.
message("Step 2: Computing user-generated paths for all trees...")
all_user_paths <- future_lapply(1:n_tree, get_paths, future.packages = "randomForest")
# --- 3. 정답과 내 코드의 답 비교 ---
message("Step 3: Comparing user-generated paths with ground truth...")
mismatch_found <- FALSE
mismatch_details <- list()
for (t in 1:n_tree) {
# t번째 트리의 '정답' 말단 노드 벡터
truth_nodes_for_tree_t <- predicted_nodes[, t]
# t번째 트리의 '내 코드'가 계산한 경로 리스트
user_paths_for_tree_t <- all_user_paths[[t]]
# '내 코드' 경로에서 마지막 노드(말단 노드)만 추출
user_final_nodes_for_tree_t <- sapply(user_paths_for_tree_t, function(p) p[length(p)])
# 두 벡터가 완전히 일치하는지 확인
if (!all(truth_nodes_for_tree_t == user_final_nodes_for_tree_t)) {
mismatch_found <- TRUE
# 불일치가 발생한 첫 번째 관측치 인덱스 찾기 (리포팅용)
first_mismatch_idx <- which(truth_nodes_for_tree_t != user_final_nodes_for_tree_t)[1]
# 불일치 정보 저장
mismatch_info <- list(
tree_number = t,
first_mismatch_at_observation_index = first_mismatch_idx,
ground_truth_node = truth_nodes_for_tree_t[first_mismatch_idx],
user_generated_final_node = user_final_nodes_for_tree_t[first_mismatch_idx]
)
mismatch_details[[length(mismatch_details) + 1]] <- mismatch_info
}
}
# --- 4. 최종 결과 리포트 ---
message("\n--- Validation Report ---")
if (mismatch_found) {
cat("🔴 Mismatch Found! 'get_paths' 함수가 randomForest의 실제 경로와 일치하지 않습니다.\n\n")
cat("불일치가 발견된 트리의 상세 정보:\n")
for(info in mismatch_details) {
cat(sprintf("  - Tree #%d: Observation #%d에서 불일치 (정답 노드: %d, 내 코드 결과: %d)\n",
info$tree_number,
info$first_mismatch_at_observation_index,
info$ground_truth_node,
info$user_generated_final_node))
}
cat("\n➡️ 추천: 범주형 변수(factor) 처리 로직을 검토해야 합니다.\n")
} else {
cat("✅ Success! 모든 생성 경로가 predict() 함수의 결과와 완벽하게 일치합니다.\n")
cat("➡️ 'get_paths' 함수의 정확성이 검증되었습니다.\n")
}
# --- [검증 코드 종료] ---
# ---- 3. Compute all paths in parallel ----
message("Computing paths for all trees in parallel...")
all_paths <- future_lapply(1:n_tree, get_paths, future.packages = "randomForest")
# ---- 4. Compute proximity matrix in parallel ----
message("Calculating path proximity matrix in parallel...")
proximity <- matrix(0, nrow = n, ncol = n)
p <- progressor(steps = n_tree)
tree_jaccard <- function(b) {
paths <- all_paths[[b]]
mtx <- matrix(0, nrow = n, ncol = n)
for (i in 1:n) {
Ti <- paths[[i]]
for (j in i:n) {
Tj <- paths[[j]]
intersect_len <- length(intersect(Ti, Tj))
union_len <- length(union(Ti, Tj))
jaccard <- intersect_len / union_len
mtx[i, j] <- jaccard
if (i != j) mtx[j, i] <- jaccard
}
}
p()
return(mtx)
}
with_progress({
mtx_list <- future_lapply(1:n_tree, tree_jaccard)
})
# ---- 5. Aggregate and normalize the results ----
for (m in mtx_list) {
proximity <- proximity + m
}
proximity <- proximity / n_tree
rownames(proximity) <- rownames(data)
colnames(proximity) <- rownames(data)
return(proximity)
}
P <- compute_path_proximity(data)
write_rds(P, "PathProximity.rds")
off_diag_values <- P[lower.tri(P)]
summary(off_diag_values)
hist(off_diag_values)
zero_ratio <- mean(off_diag_values == 0)
cat("Proportion of exact zeros in off-diagonal:", round(zero_ratio * 100, 2), "%\n")
diag_values <- diag(P)
summary(diag_values)
